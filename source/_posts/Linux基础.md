---
title: Linux基础
---
# Linux笔记



## 第一二三章 前言

### 3.6 网络连接的三种模式

1. 桥接模式：虚拟系统可以和外部系统通讯，但是容易造成IP冲突
2. NAT模式(网络地址转换)：虚拟系统可以和外部系统通讯，不造成IP冲突
3. 主机模式：独立的系统



### 3.7 虚拟机克隆

​	如果你已经安装了一台Linux操作系统，还想要更多，没有必要重新安装，只需要克隆即可

- 方式1、直接拷贝一份安装好的虚拟机文件

- 方式2、使用VMware的克隆操作

  注意：克隆时，需要先关闭Linux系统
  
  



### 3.8 虚拟机快照

​	如果在使用虚拟机系统的时候（例如Linux），想回到原先的某一个状态，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，VMware也提供了这样的的功能，叫做快照管理



### 3.9 虚拟机迁移和删除

​	虚拟系统安装好了，它的本质就是文件（放在文件夹里的）。因此虚拟系统的迁移很方便，可以把安装好的虚拟系统这个文件夹整体拷贝或者剪切到另外位置使用。删除也很简单，用VMware进行移除，再点击菜单->从磁盘删除即可，或者直接手动删除虚拟系统对应的文件夹即可。



### 3.10 安装VMtools

安装VMtools步骤：

1. 进入CentOS
2. 点击VM菜单的->`install vmware tools`
3. CentOs会出现一个VM的安装包，`xx.tar.gz`
4. 拷贝到`/opt`
5. 使用解压命令`tar`，得到一个安装文件
6. 进入该vm解压的目录`/opt`目录下
7. 安装`./vmware-install.pl`
8. 全部使用默认设置即可，就可以安装成功
9. 注意：安装VMtools需要有gcc



### 3.11 设置共享文件夹

​	为了方便，可以设置一个共享文件夹，比如 `d:/myshare`

​	具体步骤：

1. 菜单->VM->setting，设置选项为`always enable`，这样就可以读写了
2. windows和CentOS可共享`d:/myshare`目录可以读写文件了
3. 共享文件夹在CentOS的`/mnt/hgfs/`下

​	注意事项和细节说明：

- windows和CentOS就可以共享文件了，但是在实际开发中，文件的上传下载是需要使用远程方式完成的



## 第四章 Linux目录结构

基本介绍：

- Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录`/`，然后在此目录下再创建其他的目录
- 深刻理解Linux树状文件目录是非常重要的
- 记住一句经典的话：在Linux世界里，一切皆文件



具体的目录结构：

- `/bin`[常用]（`/usr/bin`、`/usr/local/bin`）
  - 是Binary的缩写，这个目录存放着最经常使用的命令
- `/sbin`（`/usr/sbin`、`/usr/local/sbin`）
  - s就是super user的意思，这里存放的是系统管理员使用的系统管理程序
- `home/`[常用]
  - 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录是以用户的账号命名
- `/root`[常用]
  - 该目录为系统管理员，也称作超级权限者的用户主目录
- `/lib`
  - 系统开机所需要的最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库
- `/lost+found`
  - 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件
- `/etc`[常用]
  - 所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库my.conf
- `/usr`[常用]
  - 这是一个非常重要的目录，用户很多应用程序和文件都放在这个目录下，类似于windows下的`pregram files`目录
- `/boot`[常用]
  - 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件
- `/proc`
  - 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录获取系统信息
- `/srv`
  - service缩写，该目录存放一些服务启动之后需要提取的数据
- `/sys`
  - 这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统`sysfs`
- `/tmp`
  - 这个目录是用来存放一些临时文件的
- `/dev`
  - 类似于windows的设备管理器，把所有的硬件用文件形式存储
- `/media`[常用]
  - Linux系统会自动识别一些设备，例如U盘、光驱等，当识别后，Linux会把识别的设备挂载到这个目录下
- `/mnt`[常用]
  - 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在`/mnt/`上，然后进入该目录就可以查看里面的内容了。`d:/myshare`
- `/opt`
  - 这是给主机额外安装软件所存放的目录。如安装ORACLE数据库就可以放到该目录下。默认为空
- `/usr/local`[常用]
  - 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序
- `/var`[常用]
  - 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件
- `/selinux`[security-enhenced linux]
  - SElinux是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置



# Linux实操篇



## 第五章 远程登录到Linux服务器

### 5.1 为什么需要远程登陆Linux

说明：公司在开发时候，具体的应用场景是这样的

1. Linux服务器是开发小组共享
2. 正式上线的项目是运行在公网
3. 因此程序员需要远程登录到Linux进行项目管理或者开发
4. 画出简单的网络拓扑示意
5. 远程登陆客户端有`Xshell6`、`Xftp6`等，其他远程工具大同小异



### 5.2 远程登陆Linux-Xshell6

介绍：

​	Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了中文乱码的问题，是目前程序员首选的软件

​	Xshell 是一个强大的安全终端模拟软件，它支持SSH1，SSH2，以及Microsoft Windows 平台的TELENT 协议

​	Xshell 可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的



### 6.3 远程上传下载文件-Xftp6

介绍：

​	Xftp6 是一个基于Windows 平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，Windows用户能安全地在UNIX/Linux 和Windows PC 之间传输文件



## 第六章 Vi 和Vim 编辑器

​	Linux 系统会内置Vi 文本编辑器

​	Vim 具有程序编辑的能力，可以看做是Vi 的增强版本，可以主动地以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编译的功能特别丰富，在程序员中被广泛使用。



### 6.1 Vi 和Vim 常用的三种模式

- 正常模式
  - 以Vim 打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中，你可以使用` ↑ ↓ ← → `按键来移动光标，你可以使用`删除字符`或`删除整行`来处理档案内容，也可以使用`复制、粘贴`来处理你的文件数据。
- 插入模式
  - 按下` i I o O a A r R `等任意一个字母之后采后进入编辑模式，一般来说按`i`即可。退出此模式进入正常模式按`ESC`键。
- 命令行模式
  - 输入`:`或者`/`切换至此模式在这个模式中，可以提供你相关指令，完成读取、存盘、替换、离开Vim 、显示行号等的动作。在命令行下输入`:wq`(保存退出)、`:q`(退出)、`:q!`(强制退出，不保存)。退出此模式进入正常模式按`ESC`键。



### 6.2 Vi 和Vim 快捷键

**快捷键使用联系：**

1. 拷贝当前行`yy`，拷贝当前行向下的5行`5yy`，并粘贴`p`
2. 删除当前行`dd`，删除当前行向下的5行`5dd`
3. 在文件中查找某个单词 `[命令行/关键字，回车 查找，输入n就是查找下一个]`
4. 设置文件的行号，取消文件的行号`[命令行下 :set nu 和 :ser nonu]`
5. 编辑`/etc/profile`文件，在一般模式下使用快捷键到该文档的最末行`G`和最首行`gg`
6. 在一个文件中输入"hello"，然后又撤销这个动作 `u`
7. 编辑`/etc/profile`文件，并将光标移动到20行`20+shift+g`



## 第七章 开机、重启和用户登陆注销

### 7.1 关机&重启命令

- 基本介绍

​		`shutdown -h now`		立即进行关机

​		`shutdown -h 1`			"hello ,1分钟后会关机"

​		`shutdown -r now`		现在重启计算机

​		`halt`								关机，作用和上面一样

​		`reboot`							现在重新启动计算机

​		`sync`								把内存的数据同步到磁盘

- 注意细节

1. 不管是重启系统还是关闭系统，首先要运行`sync`命令，把内存中的数据写道磁盘中
2. 目前的`shutdown/reboot/halt`等命令均已经在关机前进行了`sync`，但小心使得的万年船



### 7.2 用户登陆和注销

- 基本介绍

1. 登陆时尽量少用root账号登陆，因为它是管理员，最大的权限，避免操作失误。可以利用普通用户登陆，登陆后再用`su - 用户名`命令来切换系统管理员身份
2. 在提示符下输入`logout`即可注销用户

- 使用细节

​		`logout`注销指令在图形运行级别无效，在运行级别3下有效



## 第八章 用户管理

​	基本介绍：

​		Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统



### 8.1 添加用户

- 基本语法

​		`useradd 用户名`

- 细节说明

1. 当创建用户成功后，会自动地创建和用户同名的家目录
2. 也可以通过`useradd -d 指定目录 新的用户名`，给新创建的用户指定家目录



### 8.2 指定/修改密码

- 基本语法

​		`passwd 用户名`

​	补充：显示当前用户所在的目录 `pwd`



### 8.3 删除用户

- 基本语法

​		`userdel 用户名`

- 应用案例

1. 删除用户milan，但是要保留家目录 `userdel milan`
2. 删除用户以及用户主目录tom `userdel -r tom`

​	注意：删除用户及其主目录操作慎用！！！



### 8.4 查询用户信息指令

- 基本语法

​		`id 用户名`



### 8.5 切换用户

- 介绍

  ​	在操作Linux中，如果当前用户的权限不够，可以通过`su`指令，切换到高权限用户，比如`root`

- 基本语法

​			`su - 需要切换的用户名`

- 细节说明

1. 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要
2. 当需要返回原来用户是，使用`exit`/`logout`指令



### 8.6 查看当前用户/登录用户

- 查看当前用户：`whoami`
- 查看登录用户：`who am i`



### 8.7 用户组

- 介绍

​		类似于角色，系统可以对有共性的多个用户进行统一的管理

- 新增组

​		基本语法：`groupadd 组名`

- 删除组

​		基本语法：`groupdel 组名`

- 增加用户时直接加上组

​		基本语法：`useradd -g 用户组 用户名`

- 修改用户组

​		基本语法：`usermod -g 用户组 用户名`



### 8.8 用户和组相关文件

- `/etc/paswd`文件

​		用户（user）的配置文件，记录用户的各种信息

​		每行的含义：`用户名：口令：用户标识号：组标识号：注释性描述：主目录：登陆Shell`

- `etc/shadow`文件

​		口令的配置文件

​		每行的含义：`登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：浸警告时间：不活动时间：失效指令：标志`

- `etc/group`文件

​		组（group）的配置文件，记录Linux包含的组的信息

​		每行含义：`组名：口令：组标识号：组内用户列表`



## 第九章  实用指令

### 9.1 指定运行级别

基本介绍

- 运行级别说明：
  - 0：关机
  - 1：单用户【找回丢失密码】
  - 2：多用户状态没有网络服务
  - 3：(multi-user)多用户状态有网络服务
  - 4：系统未使用保留给用户
  - 5：(graphical)图形界面
  - 6：系统重启
  - 注：常用运行级别是3和5，也可以指定运行级别
- 运行指令：`init 0/1/2/3/4/5/6`
- CentOS7后运行级别说明
  - 在CentOS7以前，`etc/inittab`文件中
  - CentOS7以后进行了简化:
    - `multi-user.target:analogous to runlevel 3`
    - `graphical.target:analogous to runlevel 5`
  - 查看默认运行级别：
    - `systemctl get-default`
  - 设置默认运行级别：
    - `systemctl set-default TARGET.target`



### 9.2 root密码找回

1. 首先，启动系统，进入开机界面，在界面中按`e`进入编辑界面
2. 进入编辑界面，使用键盘的上下键把光标往下移动，找到以`Linux16`开头内容所在的行数，在行的最后面输入：`init=/bin/sh`
3. 接着，输入完成后，直接快捷键`Ctrl+X`进入单用户模式
4. 接着，在光标闪烁的位置中输入：`mount -o remount,rw /`完成后按`Enter`
5. 在新的一行最后面输入：`passwd`，完成后按键盘的回车`Enter`。输入密码，然后在确认密码即可，密码修改成功后，会显示`passwd......`样式，说明密码修改成功。
6. 在光标闪烁位置中（最后一行）输入：`touch /.autorelabel`,完成后按键盘回车键`Enter`
7. 继续在光标闪烁的位置输入：`exec /sbin/init`，完成后按回车键，等待系统自动修改密码（过程可能有点长，耐心等待），完成后，系统会自动重启，新的密码就会生效	



### 9.3 帮助指令

- man 获得帮助信息
  - 基本语法：`man [命令或配置文件]`（功能描述：获得帮助信息）
  - 案例：查看`ls`命令的帮助信息`man ls`
  - 在Linux下，隐藏文件是以`.`开头的
  - 选项可以组合使用，例如`ls -al`/`ls -al /root`
- help 指令
  - 基本语法：`help 命令`（功能描述：获得shell内置命令的帮助信息）



### 9.4 文件目录类指令

- pwd 命令

  - 基本语法：`pwd`（功能描述：显示当前工作目录的绝对路径）
- ls 指令

  - 基本语法：`ls [选项] [目录或是文件]`
  - 常用选项：
    - `-a`：显示当前目录所有的文件或目录，包含隐藏的
    - `-l`：以列表的方式显示信息
- cd 指令

  - 基本语法：`cd [参数]`（功能描述：切换到指定目录）
  - 理解：绝对路径和相对路径
  - `cd ~`或者`cd`回到自己的家目录
  - `cd ..`回到当前目录的上一级目录
- mkdir 命令

  - mkdir 指令用于创建目录
  - 基本语法：`mkdir [选项] 要创建的目录`
  - 常用选项：
    - `-p`：创建多级目录
- rmdir 指令

  - rmdir 指令删除空目录
  - 基本语法：`rmdir [选项] 要删除的空目录`
  - 使用细节：
    - rmdir 删除的是空目录，如果目录下有内容时无法删除
    - 提示：如果需要删除非空目录，需要使用`rm -rf 要删除的目录`

- touch 指令

  - touch 指令创建空文件
  - 基本语法：`touch 文件名称`
- cp 指令
  - cp 指令拷贝文件到指定目录
  - 基本语法：`cp [选项] source dest`
  - 常用选项：
    - `-r`：递归复制整个文件夹
  - 使用细节
    - 强制覆盖不提示的方法：`\cp`
- rm 指令
  - 说明：rm 指令一处文件或目录
  - 基本语法：`rm [选项] 要删除的文件或目录`
  - 常用选项：
    - `-r`：递归删除整个文件夹
    - `-f`：强制删除不提示
- mv 指令
  - mv 移动文件与目录或重命名
  - 基本语法：
    - `mv oldNameFile newNamwFile`（功能描述：重命名）
    - `mv /temp/movefile /targetFolder`（功能描述：移动文件）
- cat 指令
  - cat 查看文件内容
  - 基本语法：`cat [选项] 要查看的文件`
  - 常用选项：
    - `-n`：显示行号
  - 使用细节：
    - `cat`只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令`| more`
- more 指令
  - more 指令是一个基于VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容
  - 基本语法：`more 要查看的文件`
  - 进入文件后快捷键：
    - `空格键(space)`：代表向下翻一页
    - `Enter`：代表向下翻一行
    - `q`：代表立刻离开more，不再显示文件内容
    - `Ctrl+F`：向下滚动一屏
    - `Ctrl+B`：返回上一屏
    - `=`：输出当前行的行号
    - `:f`：输出文件名和当前行的行号
- less 指令
  - less 指令用来分屏查看文件内容，它与功能more 指令类似，但是比more 指令更加强大，支持各种终端显示。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，二十更具显示需要加载内容，对于大型文件具有极高的效率
  - 基本语法：`less 要查看的文件`
  - 进入文件后快捷键：
    - `空格键(space)`：向下翻动一页
    - `[pagedown]`：向下翻动一页
    - `[pageup]`：向上翻动一页
    - `/字串`：向下搜寻`字串`的功能；`n`：向下查找；`N`：向上查找
    - `?字串`：向上搜寻`字串`的功能；`n`：向上查找；`N`：向上查找
    - `q`：离开less 这个程序
- echo 指令
  - echo 输出内容到控制台
  - 基本语法：`echo [选项] [输出内容]`
  - 案例：
    - 使用echo 指令输出环境变量，例如`$PATH`、`$HOSTNAME`
    - 使用echo 指令输出`helloLinux`
- head 指令
  - head 用域显示文件开头部分内容，默认情况下head 指令显示文件的前10行内容
  - 基本语法：
    - `head 文件`（功能描述：查看文件头10行内容）
    - `head -n 5 文件`（功能描述：查看文件头5行内容，可以是任意整数）
- tail 指令
  - tail 指令用于输出文件尾部的内容，默认情况下tail 指令显示文件的前10行内容
  - 基本语法：
    - `tail 文件`（功能描述：查看文件尾10行内容）
    - `tail -n 5 文件`（功能描述：查看文件尾5行内容，可以是任意整数）
    - `tail -f 文件`（功能描述：实时追踪该文档的所有更新）
- `>`指令和`>>`指令
  - `>`输出重定向和`>>`追加
  - 基本语法：
    - `ls -l > 文件`（功能描述：列表的内容写入文件中（覆盖写））
    - `ls -al >> 文件`（功能描述：列表的内容追加到文件的末尾）
    - `cat 文件1 > 文件2`（功能描述：将文件1的内容覆盖到文件2）
    - `echo "内容" >> 文件`（功能描述：追加）
  - 注意：两个箭头追加，一个箭头覆盖
- ln 指令
  - 软链接也称为符号链接，类似于Windows 里的快捷方式，主要存放了其他文件的路径
  - 基本语法：
    - `ln -s [原文件或目录] [软链接名]`（功能描述：给原文件创建一个软链接）
  - 细节说明：
    - 当我们使用pwd 指令查看目录时，任然看到的是软链接所在的目录
- history 指令
  - 查看已经执行过的历史命令，也可以执行历史指令
  - 基本语法：`history`
  - 案例：
    - 显示所有历史命令：`history`
    - 显示最近使用过的10个指令：`history 10`
    - 执行历史编号为5的指令：`!5`



### 9.5 时间日期类指令

- date 指令
  - 显示当前日期
  - 基本语法：
    - `date`（显示当前时间）
    - `date +%Y`（显示当前年份）
    - `date +%m`（显示当前月份）
    - `date +%d`（显示当前哪一天）
    - `date "+%Y-%m-%d %H:%M:%S"`（显示年月日时分秒）
    - `date -s 字符串时间`（设置日期）
- cal 指令
  - 查看日历指令
  - 基本语法：
    - `cal [选项]`（不加选项，显示本月日历）



### 9.6 搜索查找类指令

- find 指令
  - find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端
  - 基本语法：
    - `find [搜索范围] [选项]`
  - 选项说明：
    - `-name<查询方式>`：按照指定的文件名查找模式查找文件
    - `-user<用户名>`：查找属于指定用户名所有文件
    - `-size<文件大小>`：按照指定文件大小查找文件
      - `+n` 大于n；`-n` 小于n；`n` 等于n；单位有：k，M，G
- locate 指令
  - locate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的locate 数据库实现快速定位给定的文件。locate 指令无需便利整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate 时刻
  - 基本语法
    - `locate 搜索文件`
  - 特别说明
    - 由于locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库
- which 指令
  - 可以查看某个指令在哪个目录下
- grep 指令和管道符号`|`
  - grep 过滤查找，管道符号`|`，表示将前一个命令的处理结果输出传递给后面的命令处理
  - 基本语法：
    - `grep [选项] 查找内容 源文件`
  - 常用选项：
    - `-n`：显示匹配行及行号
    - `-i`：忽略字母大小写



### 9.7 压缩和解压类指令

- gzip /gunzip 指令
  - gzip 用于压缩文件；gunzip 用于解压
  - 基本语法：
    - `gzip 文件`（压缩文件，只能将文件压缩为`*.gz`文件）
    - `gunzip 文件.gz`（解压缩文件命令）
- zip /unzip 指令
  - zip 用于压缩文件；unzip 用于解压，这个在项目打包发布中很有用
  - 基本语法:
    - `zip [选项] XXX.zip 将要压缩的内容`（压缩文件和目录的命令）
    - `unzip [选项] XXX.zip`（解压缩文件）
  - zip 常用选项:
    - `-r`：递归压缩，即压缩目录
  - unzip 常用选项:
    - `-d<目录>`：指定解压后文件的存放目录
- tar 指令
  - tar 指令是打包指令，最后打包的文件是`.tar.gz`的文件
  - 基本语法：
    - `tar [选项] XXX.tar.gz 打包的内容`（打包目录，压缩后的文件格式`.tar.gz`）
  - 选项说明：
    - `-c`：产生`.tar`打包文件
    - `-v`：显示详细信息
    - `-f`：指定压缩后的文件名
    - `-z`：打包同时压缩
    - `-x`：解包`.tar`文件
  - 应用实例：
    - 案例1：压缩多个文件，将`/home/pig.txt`和`/home/cat.txt`压缩成`pc.tar.gz`
      - `tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt`
    -  案例2：将`/home`的文件夹压缩成`myhome.tar.gz`
      - `tar -zcvf myhome.tar.gz /home/`
    - 案例3：将`pc.tar.gz`解压到当前目录
      - `tar -zxvf pc.tar.gz`
    - 案例4：将`myhome.tar.gz`解压到`/opt/tmp2`目录下
      - `tar -zxvf /home/myhome.tar.gz -C /opt/tmp2`



## 第十章 组管理和权限管理



### 10.1 Linux组基本介绍

​	在Linux中的每个用户必须属于一个组，不能独立于组外。在Linux中每个文件有所有者，所在组，其他组的概念



### 10.2 文件/目录 所有者

​	一般为文件的创建者

- 查看文件的所有者
  - 指令：`ls -ahl`
- 修改文件所有者
  - 指令：`chown 用户名 文件名`



### 10.3 组

- 组的创建基本指令
  - `groupadd 组名`
- 修改文件所在组基本指令
  - `chgrp 组名 文件名`



### 10.4 其他组

​	除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组

- 改变用户所在组
  - 在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组
  - 基本指令:
    - `usermod -g 组名 用户名`
    - `usermod -d 目录名 用户名`（改变该用户登陆的初始目录）
  - 特别说明：
    - 用户需要有进入到新目录的权限



### 10.5 权限的基本介绍

​	`ls -l`中显示的内容如下：

​		`-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc`

​	0~9位说明：

1. 第0位确定文件类型（d，-，I，c，b）

   ​	`I`是链接，相当于Windows的快捷方式

   ​	`d`是目录，相当于Windows的文件夹

   ​	`c`是字符设备文件，鼠标，键盘

   ​	`b`是块设备，比如硬盘

2. 第1~3位确定所有者（该文件的所有者）拥有该文件的权限。---User

3. 第4~6位确定所属组（该用户组的）拥有该文件的权限。---Group

4. 第7~9位确定其它用户拥有该文件的权限。---Other

**rwx 权限详解**

- rwx 作用到文件
  1. `[r]`代表可读（read）：可以读取，查看
  2. `[w]`代表可写（write）：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在目录有写权限，才能删除该文件
  3. `[x]`代表可执行（execute）：可以被执行
- rwx 作用到目录
  1. `[r]`代表可读（read）：可以读取，ls 查看目录内容
  2. `[w]`代表可写（write）：可以修改，对目录内创建+删除+重命名目录
  3. `[x]`代表可执行（execute）：可以进入该目录

**文件及目录权限实际案例**

- `ls -l`中显示的内容如下

  `-rwxrw-r-- 1 root root 1213 Feb 2 09:30 abc`

  10个字符确定不同用户能对文件干什么

  - 第一个字符代表文件类型：`- l d c b`
  - 其余字符每三个一组（rwx）读（r）写（write）执行（execute）
  - 第一组`rwx`：文件拥有者的权限是读、写和执行
  - 第二组`rw-`：与文件拥有者同一组的用户的权限是读、写但不能执行
  - 第三组`r--`：不与文件拥有者同组的其他用户的权限是读不能写和执行

  可用数字表示为：r=4，w=2，x=1，因此 rwx=4+2+1=7

  其他说明

  - `1`                      文件：硬链接数 目录：子目录数
  - `root`                 用户
  - `root`                 组
  - `1213`                 文件大小（字节），如果是文件夹，显示 4096 字节
  - `Feb 2 09:39`     最后修改日期
  - `abc`                   文件名



### 10.6 修改权限、所有者/组

**修改权限`-chmod`**

**基本说明**

- 通过`chmod`指令，可以修改文件或者目录的权限

**第一种方式：+、-、=变更权限**

- u：所有者 g：所有者 o：其他人 a：所有人（u、g、o的总和）
  1. `chmod u=rwx,g=rx,o=x 文件/目录名`
  2. `chmod o+w 文件/目录名`
  3. `chmod a-x 文件/目录名`

**第二种方式：通过数字变更权限**

- r=4，w=2，x=1   rwx=4+2+1=7
- `chmod u=rwx,g=rx,o=x`相当于`chmod 751 文件目录名`



**修改文件所有者`-chown`**

基本介绍

- `chown newowner 文件/目录`改变所有者
- `chown newowner:newgroup 文件/目录`改变所有者和所在组
- `-R`如果是目录，则使其下所有的子文件或目录递归生效

**修改文件/所在组`-chgrp`**

基本介绍

- `chgrp newgroup 文件/目录 改变所有组`



## 第十一章 定时任务调度

### 11.1 crond 任务调度

crontab 进行 定时任务的设置

**概述** 

- 任务调度：是指系统在某个时间执行的特定的命令或程序
- 任务调度分类：
  - 系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等
  - 个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份

**基本语法**

- `crontab [选项]`

**常用选项**

- `-e`：编辑 crontab 定时任务
- `-l`：查询 crontab 任务
- `-r`：删除当前用户所有的 crontab 任务
- `service crond restart`：重启任务调度

**快速入门**

- 设置任务调度文件：`/etc/crontab`
- 设置个人任务调度。执行`crontab -e`命令
- 接着输入任务到调度文件
- 如：`*/1 * * * * ls -l /etc/ > /tmp/to.txt`命令

**参数细节说明**

| 项目      | 含义                 | 范围                    |
| --------- | -------------------- | ----------------------- |
| 第一个`*` | 一小时当中的第几分钟 | 0-59                    |
| 第二个`*` | 一天当中的第几小时   | 0-23                    |
| 第三个`*` | 一个月当中的第几天   | 1-31                    |
| 第四个`*` | 一年当中的第几月     | 1-12                    |
| 第五个`*` | 一周当中的星期几     | 0-7（0和7都代表星期日） |

**特殊符号的说明**

| 特殊符号 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| *        | 代表任何时间。比如第一个`*`就代表一小时中每分钟都执行一次的意思 |
| ,        | 代表不连续的时间。比如：`0 8,12,16 * * * 命令`，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 |
| -        | 代表连续时间范围。比如：`0 5 * * 1-6 命令`，代表在周一到周六的凌晨5点0分执行命令 |
| */n      | 代表每隔多久执行一次。比如：`*/10 * * * * 命令`，代表每隔10分钟就执行一遍命令 |

**特殊时间执行任务案例**

| 时间                | 含义                                     |
| ------------------- | ---------------------------------------- |
| `45 22 * * * 命令`  | 在22点45分执行命令                       |
| `0 17 * * 1 命令`   | 每周1的17点0分执行命令                   |
| `0 5 1,15 * * 命令` | 每月1号和15号的凌晨5点0分执行命令        |
| `40 4 * * 1-5 命令` | 每周一到周五的凌晨4点40分执行命令        |
| `*/10 4 * * * 命令` | 每天的凌晨4点，每隔10分钟执行一次命令    |
| `0 0 1,15 * 1 命令` | 每月1号和15号，每周1的0点0分都会执行命令 |

注意：星期几和几号最好不要同时出现，因为它们定义的都是天。非常容易让管理员混乱

**应用实例**

- 案例1：每隔1分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中
  - `*/1 * * * * date >> /tmp/mtdate`
- 案例2：每隔1分钟，就将当前日期和日历都追加到 /home/mycal 文件中
  1. `vim /home/my.sh`写入内容`date >> /home/mycal`和`cal >> /home/mycal`
  2. 给 my.sh 增加执行权限：`chmod u+x /home/my.sh`
  3. `crontab -e`增加`*/1 * * * * /home/my.sh`
- 案例3：每天凌晨2点将mysql数据库 testdb，备份到文件中
  - `0 2 * * * mysqldump -u root -proof testdb >> /home/db.bak`



### 11.2 at 定时任务

**基本介绍**

- at 命令是一次性定时计划任务，at的守护进程 atd 会以后台模式运行，检查作业队列开运行
- 默认情况下，atd 守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业
- at 命令是一次性定时计划任务，执行完一个任务后不再执行此任务了
- 在使用 at 命令时，一定要保证 atd 进程的启动，可以使用相关指令来查看
  - `ps -ef | grep atd`：可以检测 atd 是否在运行

**at 命令格式**

- `at [选项][时间]`
- `Ctrl + D`结束 at 命令的输入

**at 命令选项**

| 选项           | 含义                                                     |
| -------------- | -------------------------------------------------------- |
| `-m`           | 当指定的任务被完成后，将给用户发送邮件，即使没有标准输出 |
| `-I`           | atq 的别名                                               |
| `-d`           | atrm 的别名                                              |
| `-v`           | 显示任务将被执行的时间                                   |
| `-c`           | 打印任务的内容到标准输出                                 |
| `-V`           | 显示版本信息                                             |
| `-q<队列>`     | 使用指定的队列                                           |
| `-f<文件>`     | 从指定文件读入任务而不是从标准输入读入                   |
| `-t<时间参数>` | 以时间参数的形式提交要运行的任务                         |

**at 时间定义**

1. 接受在当天的 hh:mm 式的时间指定。假如该时间已过去，那么就放在第二天执行。例如：04:00
2. 使用 midnight，noon，teatime(饮茶时间，一般下午4点)等比较模糊的词语来指定时间
3. 采用12小事计时制，即在时间后面加上 AM或PM。例如：12pm
4. 指定命令执行的具体日期，指定格式为 month day 或 mm/dd/yy 或 dd.mm.yy，指定的日期必须跟在指定时间的后面。例如：04:00 2021-03-1
5. 使用相对计时法。指定格式为：now + count time-units，now 就是当前时间，time-units是时间单位，这里能够是 minutes、hours、days、weeks。count是时间的数量，几天，几小时。例如：now + 5 minutes
6. 直接使用 today、tomorrow 来指定完成命令的时间

**应用案例**

- 案例1：2天后的下午5点执行 /bin/ls /home
  1. `at 5pm + 2day`
  2. `/bin/ls /home`
  3. 两次`Ctrl+D`退出
- 案例2：atq 命令来查看系统中有没有执行的工作任务
  - `atq`
- 案例3：明天17点中，输出时间到知道那个文件内 比如 /toot/date100.log
  1. `at 5pm tomorrow`
  2. `date > /root/date100.log`
- 案例4：2分钟后，输出时间到指定文件内 比如 /root/date200.log
  1. `at now + 2 minutes`
  2. `date > /root/date200.log`
- 案例5：删除已设置的任务，atrm 编号
  - `atrm 编号`



## 第十二章 Linux 磁盘分区、挂载

### 12.1 Linux 分区

**原理介绍**

1. Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux 中每个分区都是用来组成整个文件系统的一部分
2. Linux 采用了一种叫“载入”的处理方法，它整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得

**硬盘说明**

1. Linux 硬盘分为 IDE硬盘 和 SCSI硬盘，目前基本上是 SCSI硬盘
2. 对于 IDE硬盘，驱动器标识符为 "hdx~"，其中 "hd" 表明分区所在设备的类型，这里是指 IDE硬盘了。"x"为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘），"~" 代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例：hda3 表示为第一个 IDE硬盘 上的第三个主分区或扩展分区
3. 对于 SCSI硬盘 则标识为 "sdx~"，SCSI硬盘 是用 "sd" 来表示分区所在设备的类型的，其余则和 IDE硬盘 的表示方法一样

**查看所有设备挂载情况**

- `lsblk`或者`lsblk -f`

**挂载经典案例**

说明

- 下面我们以增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念

如何增加一块硬盘

1. 虚拟机添加硬盘
   - 在虚拟机菜单中，选择设置，然后设备列表里添加硬盘，然后一路下一步，中间只有选择磁盘大小的地方需要修改，直至完成。然后重启系统（才能识别）
2. 分区
   1. 分区命令：`fdisk /dev/sdb`
   2. 开始对`/sdb`分区
      - `m`：显示命令列表
      - `p`：显示磁盘分区 同`fdisk -l`
      - `n`：新增分区
      - `d`：删除分区
      - `w`：写入并退出
      - 说明：开始分区后输入`n`，新增分区，然后选择`p`，分区类型为主分区。两次回车默认甚于全部空间。最后输入`w`写入分区并退出，如不保存退出输入`q`
3. 格式化
   - 格式化磁盘分区命令：`mkfs -t ext4 /dev/sdb1`
   - 其中`ext4`是分区类型
4. 挂载
   1. 挂载：将一个分区与一个目录联系起来
   2. 命令：`mount 设备名称 挂载目录`
   3. 例如：`mount /dev/sdb1 /newdisk`
   4. 卸载命令：`umount /dev/sdb1`或者`umount /newdisk`
   5. **注意**：用命令行挂载，重启后会失效
5. 设置可以自动挂载
   - 永久挂载：通过修改`/etc/fstab`实现挂载
   - 添加完成后 执行`mount -a`立即生效



### 12.2 磁盘情况查询

**查询系统整体磁盘使用情况**

基本语法

- `df -h`

**查询指定目录的磁盘占用情况**

基本语法

- `du -h /目录`
- 查询指定目录的磁盘占用情况，默认为当前目录
- `-s`：指定目录占用大小汇总
- `-h`：带计量单位
- `-a`：含文件
- `--max-depth=1`：子目录深度
- `-c`：列出明细的同时，增加汇总值

**磁盘情况——工作实用指令**

1. 统计 /opt 文件夹下文件的个数
   - `ls -l /opt | grep "^-" | wc -l`
2. 统计 /opt 文件夹下目录的个数
   - `ls -l /opt | grep "^d" | wc -l`
3. 统计 /opt 文件夹下文件的个数，包括子文件夹里的
   - `ls -lR /opt | grep "^-" | wc -l`
4. 统计 /opt 文件夹下目录的个数，包括子文件夹里的
   - `ls -lR /opt | grep "^d" | wc -l`
5. 以树状显示目录结构
   - `tree 文件夹`
   - 注意：若找不到命令，则需要下载 `yum install tree`



## 第十三章 网络配置

### 13.1 基础介绍

**Linux 网络配置原理图**

![Linux 网络配置原理图](C:\Users\15640\AppData\Roaming\Typora\typora-user-images\image-20220720180131714.png)

**查看虚拟网络编辑器和修改 IP 地址**

- 查看 Windows 环境中 VMnet8 网络配置：`ipconfig`
- 查看 Linux 的网络配置：`ifconfig`

**ping 测试主机之间网络连通性**

基本语法

- `ping 目的主机`
- 功能描述：测试当前服务器是否可以连接目的主机



### 13.2 Linux 网络环境配置

**第一种方法**

- 说明：登陆后，通过界面的来设置自动获取 ip
- 特点：Linux 启动后会自动获取 IP，缺点是每次自动获取的 ip 地址可能不一样

**第二种方法**

- 说明：直接修改配置文件来指定 IP，并可以连接到外网（程序员推荐）
- 编辑：`vi /etc/sysconfig/network-scripts/ifcfg-ens33`
- 要求：将 ip 地址配置的静态的，比如：ip 地址为：192.168.200.130
- 重启网络服务或者重启系统生效
  - `service network restart`或者`reboot`

**`ifcfg-ens33`文件说明**

```shell
DEVICE=eth0		# 接口名（设备，网卡）
HWADDR=00:0C:2x:6x:0x:xx	# MAC地址
TYPE=Ethernet	# 网络类型（通常是Ethernet）
UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44	# 随机ID
# 系统启动的时候网络接口是否有效（yes/no）
ONBOOT=yes
# IP的配置方法[none|static|bootp|dhcp](引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议)
BOOTPROTO=static
# IP地址
IPADDR=192.168.200.130
# 网关
GATEWAY=192.168.200.2
# 域名解析器
DNS1=192.168.200.2
```



### 13.3 设置主机名和 hosts 映射

**设置主机名**

1. 为了方便记忆，可以给 Linux 系统设置主机名，也可以根据需要修改主机名
2. 指令`hostname`：查看主机名
3. 修改文件在`/etc/hostname`指定
4. 修改后，重启生效

**设置 hosts 映射**

思考：如何通过主机名能够找到（比如ping）某个Linux 系统？

- Windows
  - 在`C:\Windows\System32\drivers\etc\hosts`文件指定即可
  - 案例：192.168.200.130 crispEdu100
- Linux
  - 在`/etc/hosts`文件指定
  - 案例：192.168.200.1 DESKTOP-B5TP2V5

**Hosts 是什么**

​	一个文本文件，用来记录 IP 和 Hostname（主机名）的映射关系

**DNS**

1. DNS，就是Domain Name System的缩写，翻译过来就是域名系统
2. 是互联网上作为域名和 IP 地址相互映射的一个分布式数据库

**主机名解析机制分析（Hosts、DNS）**

应用案例：用户在浏览器输入了 www.baidu.com

1. 浏览器先检查浏览器缓存中有没有该域名解析 IP 地址，有就先调用这个 IP 完成解析；如果没有检查操作系统 DNS 解析器缓存，如果有直接返回 IP 完成解析。这两个缓存，可以理解为 本地解析器缓存

2. 一般来说，当电脑脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的 IP 地址（DNS解析记录）。如 在 cmd 窗口中输入

   ```shell
   ipconfig /displaydns	//DNS域名解析缓存
   ipconfig /flushdns	//手动清理dns缓存
   ```

3. 如果本地解析器缓存没有找到对应映射，检查系统中 hosts 文件中有没有配置对应的域名 IP 映射，如果有，则完成解析并返回

4. 如果 本地DNS解析器缓存 和 hosts 文件中 均没有找到对应的 IP，则到域名服务器DNS进行解析域



## 第十四章 进程管理

**基本介绍**

1. 在 Linux 中，每个执行的程序都被称为一个进程。每一个京城都分配一个 ID 号（pid，进程号）
2. 每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行
3. 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才结束

### 14.1 显示系统执行的进程

**基本介绍**

​	ps 命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数

**ps 显示的信息选项**

| 字段 | 说明                   |
| ---- | ---------------------- |
| PID  | 进程识别号             |
| TTY  | 终端机号               |
| TIME | 此进程所消耗CPU时间    |
| CMD  | 正在执行的命令或进程名 |

**可选字段**

- `ps -a`：显示当前终端的所有进程信息
- `ps -u`：以用户的格式显示进程信息
- `ps -x`：显示后台运行的参数
- `ps -ef`：另一种风格显示

**参数说明**

- USER：用户名称
- PID：进程号
- %CPU：进程占CPU的百分比
- %MEM：进程占用物理内存的百分比
- VSZ：进程占用的虚拟内存的大小（单位：KB）
- RSS：进程占用的物理内存的大小（单位：KB）
- TT：终端名称，缩写
- STAT：进程状态，其中`S-`睡眠，`s-`表示该进程是会话的先导进程，`N-`表示进程拥有比普通优先级更低的优先级，`R-`正在运行，`D-`短期等待，`Z-`僵死进程，`T-`被跟踪或者被停止等等
- STARTED：进程的启动时间
- TIME：CPU时间，即进程使用CPU的总时间
- COMMAND：启动进程所用的命令和参数，如果过长会被截断



### 14.2 终止进程 kill 和 killall

**介绍**

​	若是某个进程执行一半需要停止时，或是已消耗了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务

**基本语法**

- `kill [选项] 进程号`：通过进程号杀死进程
- `killall 进程名称`：通过进程名杀死进程，也支持通配符，这在系统负载过大而变得很慢时很有用

**常用选项**

- `-9`：表示强迫进程立即停止

**最佳实践**

1. 踢掉某个非法登录用户
   1. `ps -aux | grep sshd`查看登录用户的进程号
   2. `kill 进程号`踢出完成
2. 终止远程登陆服务 sshd，在适当时候再次重启 sshd 服务
   1. `ps -aux | grep sshd`查看 sshd服务 的进程号
   2. `kill 进程号`停止服务
   3. 重启服务：`/bin/systemctl start sshd.servise`
3. 终止多个 gedit
   - `killall gedit`
4. 强制杀掉一个终端
   1. `ps -aux | grep bash`：查看需要关闭的终端的进程号
   2. `kill -9 进程号`：需要强制关闭



### 14.3 查看进程树 pstree

**基本语法**

- `pstree [选项]`：可以更加直观的来看进程信息

**常用选项**

- `-p`：显示进程的 PID
- `-u`：显示进程的所属用户

**应用实例**

1. 请以树状的形式显示进程的 pid
   - `pstree -p`
2. 请以树状的形式进程的用户 id
   - `pstree -u`



### 14.4 服务(service)管理

**介绍**

​	服务（service）本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求（比如：mysqld，sshd，防火墙等），因此我们又称为守护进程，是 LInux中非常重要的知识点

#### 14.4.1 service 管理指令

1. service 服务名 [start | stop | restart | reload | status]
2. 在 CentOS7.0 以后 很多服务不再使用 service，二十 systemctl
3. service 指令管理的服务在 /etc/init.d 查看

**service 管理指令案例**

​	请使用 service 指令，查看，关闭，启动 network [注意：在虚拟系统演示，因为网络连接会关闭]

1. `ls -l /etc/init.d/`：查看服务
2. `service network status`：查看服务状态
3. `service network stop`：停止服务（这是其他占用22端口的应用或用户都会停止响应）
4. `service network start`：开启服务（或者使用restart）

**查看服务名**

1. 使用 setup -> 系统服务 就可以看到全部（tab键退出）
2. /etc/init.d 看到 service 指令管理的服务`ls -l /etc/init.d/`

**服务的运行级别（runlevel）**

Linux 系统有7中运行级别：常用的是级别3和级别5

- 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
- 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
- 运行级别2：多用户状态（没有NFS），不支持网络
- 运行级别3：完全的多用户状态（有NFS），登陆后进入控制台命令行模式
- 运行级别4：系统未使用，保留
- 运行级别5：X11 控制台，登陆后进入图形 GUI 模式
- 运行级别6：系统正常关闭并重启，默认与逆行级别不能设为6，否则不能正常启动

**开机流程说明**

​	开机 --> BIOS --> /boot --> systemd进程1 --> 运行级别 --> 运行级对应的服务

**CentOS7 后运行级别说明**

​	在 /etc/initab 进行了简化，如下

```shell
multi-user.target: analogous to runlevel 3
graphical.target: analogous to runlevel 5
# To view current default target, run:
systemctl get-default
# To set a default target, run:
systemctl set-default TARGET.target
```



#### 14.4.2 chkconfig 指令

**介绍**

1. 通过 chkconfig 命令可以给服务的各个运行级别设置自 启动/关闭
2. chkconfig 指令管理的服务在 /etc/init.d 查看
3. 注意：CentOS7.0 后，很多服务使用 systemctl 管理

**chkconfig 基本语法**

- 查看服务：`chkconfig --list [| grep xxx]`
- `chkconfig 服务名 --list`
- `chkconfig --level 5 服务名 on/off`

**案例演示**

​	对 network 服务在3运行级别关闭自启动

1. `chkconfig --list`：查看服务运行级别设置
2. `chkconfig --level 3 network off`

注意：chkconfig 重新设置服务后自启动或关闭，需要重启生效



#### 14.4.3 systemctl 管理指令

基本语法：`systemctl [start | stop | restart | status] 服务名`

1. systemctl 指令管理的服务在 /usr/lib/systemd/system 查看

**systemctl 设置服务的自启动状态**

1. `systemctl list-unit-files [| grep 服务名]`：查看服务开机启动状态
2. `systemctl enable 服务名`：设置服务开机启动
3. `systemctl disable 服务名`：关闭服务开机启动
4. `systemctl is-enabled 服务名`：查询某个服务是否是自启动

**应用案例**

​	查看当前防火墙的状况，关闭防火墙和重启防火墙

1. `systemctl list-unit-files | grep fire`：查看全名以及防火墙是否开机启动
2. `systemctl status firewalld.service`：查看防火墙状态
3. `systemctl stop firewalld.service`：关闭防火墙
4. `systemctl start firewalld.service`：启动防火墙

**细节讨论**

1. 关闭或者启动防火墙后，立即生效。[telnet 测试 某个端口即可]
   - 例如：在 cmd 中输入`telnet 192.168.200.130 111`
   - 若关闭防火墙，则端口 111 连接失败
2. 这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置
3. 如果希望设置某个服务自启动或关闭永久生效，要使用`systemctl [enable|disable] 服务名`



#### 14.4.4 打开或者关闭指定端口

​	在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如80、22、8080等

**firewall 指令**

- 打开端口：`firewall-cmd --permanent --add-port=端口号/协议`
- 关闭端口：`firewall-cmd --permanent --remove-port=端口号/协议`
- 重新载入，才能生效：`firewall-cmd --reload`
- 查询端口是否开放：`firewall-cmd --query-port=端口/协议`

**应用案例**

1. 启动防火墙，测试 111 端口是否能 telnet
   - 在 cmd 测试：`telnet 192.168.200.130 111`发现不能连接
2. 开放 111 端口
   1. 打开端口：`firewall-cmd --permanent --add-port=111/tcp`
   2. 重新载入：`firewall-cmd --reload`
   3. 查询是否开启：`firewall-cmd --query-port=111/tcp`
   4. 在 cmd 测试：`telnet 192.168.200.130 111`发现可以连接
3. 再次关闭 111 端口
   1. 关闭端口：`firewall-cmd --permanent --remove-port=111/tcp`
   2. 重新载入：`firewall-cmd --reload`
   3. 查询是否开启：`firewall-cmd --query-port=111/tcp`
   4. 在 cmd 测试：`telnet 192.168.200.130 111`发现无法连接



#### 14.4.5 动态监控进程

**介绍**

​	top 与 ps 命令很相似。它们都用来实现正在执行的进程。top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的进程

**基本语法**

- `top [选项]`

**选项说明**

| 选项      | 说明                                         |
| --------- | -------------------------------------------- |
| `-d 秒数` | 指定 top 命令每隔几秒更新。默认是 3 秒       |
| `-i`      | 使 top 不显示任何闲置或者僵死进程            |
| `-p`      | 通过指定监控进程 ID 来仅仅监控某个进程的状态 |

**交互操作说明**

| 操作 | 功能                            |
| :--: | ------------------------------- |
|  P   | 以 CPU 使用率排序，默认就是此项 |
|  M   | 以内存的使用率排序              |
|  N   | 以 PID 排序                     |
|  q   | 退出 top                        |

**应用实例**

1. 监视特定用户
   1. 输入`top`查看执行的进程
   2. 在 top 界面输入`u`回车，然后输入需要监视的用户名即可
2. 终止指定的进程
   1. 输入`top`查看执行的进程
   2. 然后输入`k`回车，再输入要结束的进程号
3. 指定系统状态更新的时间
   - `top -d 10`



#### 14.4.6 监控网络状态

**基本语法**

- `netstat [选项]`

**选项说明**

- `-an`：按一定顺序排序输出
- `-p`：显示哪个进程在调用

**应用案例**

​	请查看服务名为 sshd 的服务的信息

- `netstat -anp | grep sshd`





## 第十五章 RPM 与 YUM

### 15.1 rpm 包的管理

**介绍**

​	rpm 用于互联网下载包的打包及安装工具，它包含在某些 LInux 分发版中。它生成具有`.RPM`扩展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似于 Windows 的setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的

​	Linux 的分发版本都有采用（suse，redhat，centos等），可以算是公认的行业标准了

**rpm 包的简单查询指令**

​	查询已安装的 rpm 列表

- `rpm -qa | grep xx`

**rpm 包名基本格式**

​	一个 rpm 包名：`firefox-60.2.2-1.el7.centos.x86_64`

- 名称：firefox
- 版本号：60.2.2-1
- 适用操作系统：el7.centos.x86_64
  - 表示 centos7.x 的64位系统
  - 如果是i686、i386表示32位系统，noarch 表示通用

**rpm 包的其他查询指令**

- `rpm -qa`：查询所安装的所有 rpm 软件包
  - `rpm -qa | more`
  - `rpm -qa | grep X`
- `rpm -q 软件包名`：查询软件包是否安装
- `rpm -qi 软件包名`：查询软件包信息
- `rpm -ql 软件包名`：查询软件包中的文件
- `rpm -qf 文件全路径名`：查询文件所属的软件包
  - `rpm -qf /etc/passwd`
  - `rpm -qf /root/install.log`

**卸载 rpm 包**

- `rpm -e RPM包的名称`

细节讨论

1. 如果其他软件包依赖于要卸载的软件包，卸载时则会产生错误信息
   - 如：`$ rpm -e foo`
   - `removing these packages would break dependencies:foo is needed by bar-1.0-1`
2. 如果我们就是要删除 foo 这个 rpm 包，可以增加参数 `--nodeps`，就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行
   - `rpm -e --nodeps foo`

**安装 rpm 包**

基本语法

- `rpm -ivh RPM包全路径名称`

参数说明

- i=install 安装
- v=verbose 提示
- h=hash 进度条



### 15.2 yum

**介绍**

​	Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包

**yum 基本指令**

查询 yum 服务器是否有需要安装的软件

- `yum list | grep xx`

安装指定的 yum 包

- `yum install xxx`





## 第十六章 搭建 JavaEE 环境

​	如果需要在 Linux 下进行 JavaEE 的开发，需要安装以下软件

```shell
ideaIU-2020.2.3.tar.gz
apache-tomcat-8.5.59.tar.gz
mysql-5.7.26-1.el7.x86_64.rpm-bundl
jdk-8u261-linux-x64.tar.gz
CentOS-7-x86_64-DVD-1810.iso
```



### 16.1 安装 JDK

**安装步骤**

1. `mkdir /opt/jdk`
2. 通过 ftp6 上传到 `/opt/jdk`下
3. `cd /opt/jdk`
4. 解压 `tar -zxvf jdk-8u261-linux-x64.tar.gz`
5. `mkdir /usr/local/java`
6. `mv /opt/jdk/jdk1.8.0_261 /usr/local/java`
7. 配置环境变量的配置文件`vim /etc/profile`
8. `export JAVA_HOME=/usr/local/java/jdk1.9.0_161`
9. `export PATH=$JAVA_HOME/bin:$PATH`
10. `source /etc/profile`让文件生效

**测试是否安装成功**



### 16.2 安装 tomcat

**步骤**

1. 上传文件，并解压到`/opt/tomcat`
2. 进入解压目录`/bon`，启动 tomcat`./startup.sh`
3. 开放端口 8080(防火墙)

**测试是否安装成功**

- 在Windows、Linux 下访问 http://linuxip:8080



### 16.3 安装 idea2020

**步骤**

1. 下载地址：https://www.jetbrains.com/idea/download/#section=windows
2. 解压缩到`/opt/idea`
3. 启动 idea bin 目录下的`./idea.sh`，配置 jdk
4. 编写文件测试





## 第十七章 Shell编程

**为什么要学习 Shell 编程**

1. Linux 运维工程师在进行服务器集群管理时，需要编写 Shell 程序来进行服务器管理
2. 对于 JavaEE 和 Python 程序员来说，工作的要求谢谢一些 Shell 脚本进行程序或是服务器的维护，例如编写一个定时备份数据库的脚本
3. 对于大数据程序员来说，需要编写 Shell 程序来管理集群

**Shell 是什么**

​	Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序



### 17.1 Shell 脚本的执行方式

**脚本格式要求**

1. 脚本以`#!/bin/bash`开头
2. 脚本需要有可执行权限

**编写一个 Shell 脚本**

​	需求说明：创建一个 Shell 脚本，输出 hello world！

```shell
vim hello.sh
```

```shell
#!/binbash
echo "hello world~"
```

```shell
chmod u+x hello.sh ## 第一种执行方式：添加执行权限，再执行
./hello.sh
```

```shell
sh hello.sh ## 第二种执行方式 sh + 脚本
```

**脚本的常用执行方式**

- 方式一：输入脚本的绝对路径或相对路径
  - 说明：首先要赋予 helloworld.sh 脚本的 `+x` 权限，再执行脚本
- 方式二：sh+脚本
  - 说明：不用赋予脚本 +x 权限，直接执行即可



### 17.2 Shell 变量

**Shell 变量介绍**

1. Linux Shell 中的变量分为，系统变量和用户自定义变量
2. 系统变量：`$HOME、$PWD、$SHELL、$USER`等等，比如：`echo $HOME`等等
3. 显示当前 Shell 中所有的变量：`set`

**Shell 变量的定义**

基本语法

1. 定义变量：`变量=值`
2. 撤销变量：`unset 变量`
3. 声明静态变量：`readonly变量`，注意：不能 unset

快速入门

1. 定义变量A
2. 撤销变量B
3. 声明静态变量 B=2，不能 unset
4. 可把变量提升为全局变量，可供其他 shell 程序使用

**定义变量的规则**

1. 变量名称可以由字母、数字和下划线组成，但是不能以数字开头
2. 等号两侧不能有空格
3. 变量名称一般习惯为大写

**将命令的返回值赋给变量**

1. `` A=`date` ``反引号，运行里卖弄的命令，并把结果返回给变量A
2. `A=$(date)`等价于反引号



### 17.3 设置环境变量

基本语法

1. `export 变量名=变量值`（功能描述：将 Shell 变量输出为环境变量）
2. `source 配置文件`（功能描述：让修改后的配置信息立即生效）
3. `echo $变量名`（功能描述：查询环境变量的值）

快速入门

1. 在`/etc/profile`文件中定义`TOMCAT_HOME`环境变量
2. 查看环境变量`TOMCAT_HOME`的值
3. 在另外一个 Shell 程序中使用`TOMCAT_HOME`

注意：在输出`TOMCAT_HOME`环境变量前，需要让其生效`sourse /etc/profile`

**Shell 脚本的多行注释**

```shell
:<<!
内容
!
```



### 17.4 位置参数变量

**介绍**

​	当我们执行一个 Shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量

​	比如：`./myshell.sh 100 200`，这个就是一个执行 shell 的命令行，可以在 myshell 脚本中获取到参数信息

**基本语法**

- `$n`：n 为数字，`$0`代表命令本身，`$1`~`$9`代表第一到第九个参数，十以上的参数需要用大括号包含，如`${10}`
- `$*`：这个变量代表命令行中所有的参数，`$*`把所有的参数看成一个整体
- `$@`：这个变量也代表命令行中所有的参数，不过`$@`把每个参数区分对待
- `$#`：这个变量代表命令行中所有参数的个数

**位置参数变量**

​	案例：编写一个 shell 脚本 position.sh，在脚本中获取命令行的各个参数信息



### 17.5 预定义变量

**基本变量**

​	就是 shell 设计者事先已经定义好的变量，可以直接在 shell 脚本中使用

**基本语法**

- `$$`：当前进程的进程号（PID）
- `$!`：后台运行的最后一个进程的进程号
- `$?`：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了

**应用实例**

​	在一个 shell 脚本中简单使用以下预定义变量



### 17.6 运算符

**基本介绍**

​	学习如何在 shell 中进行各种运算操作

**基本语法**

1. `$((运算符))`或`$[运算符]`或者`` `expr m + n` ``
2. 注意`expr`运算符间要有空格
3. `` `expr m - n` ``
4. `` `expr \*,/,%` ``乘，除，取余

**应用实例**

- 案例1：计算（2+3）*4的值
- 案例2：请求出命令行的两个参数[整数]的和



### 17.7 条件判断

**基本语法**

- `[ condition ]`
- 注意： condition 前后要有空格
- 非空返回 true，可使用`$?`验证（0 为 true，>1 为 false）

**应用实例**

- `[ crispEdu ]`       #返回true
- `[]`                        #返回false
- `[ condition ] && echo OK || echo notok`        #条件满足，执行后面的语句

**常用判断条件**

1. `=`字符串比较
2. 两个整数的比较
   - `-lt`小于
   - `-le`小于等于
   - `-eq`等于
   - `-gt`大于
   - `-ge`大于等于
   - `-ne`不等于
3. 按照文件权限进行判断
   - `-r`有读的权限
   - `-w`有写的权限
   - `-x`有执行的权限
4. 按照文件类型进行判断
   - `-f`文件存在并且是一个常规的文件
   - `-e`文件存在
   - `-d`文件存在并是一个目录

**应用实例**

- 案例1："ok"是否等于"ok"

  - ```shell
    if [ "ok" = "ok" ]
    then
            echo "equal"
    fi
    ```

- 案例2：23 是否大于 22

  - ```shell
    if [ 23 -gt 22 ]
    then
            echo "23 > 22"
    fi
    ```

- 案例3：`/root/shcode/aaa.txt`目录中的文件是否存在

  - ```shell
    if [ -f  /root/shcode/aaa.txt ]
    then
            echo "文件存在"
    fi
    ```



### 17.8 流程控制

#### 17.8.1 if 语句

**基本语法**

```shell
if [ 条件判断式 ]
then
	代码
fi
```

或者，多分支

```shell
if [ 条件判断式 ]
then
	代码
elif [ 条件判断式 ]
then
	代码
fi
```

**注意事项**：`[ 条件判断式 ]`，中括号和条件判断式之间必须有空格

**案例**

​	编写一个 shell 程序，如果输入的参数，大于等于60，则输出 及格了，如果小于60，则输出 不及格

```shell
if [ $1 -ge 60 ]
then
        echo "及格了"
elif [ $1 -lt 60 ]
then
        echo "不及格"
fi
```



#### 17.8.2 case 语句

**基本语法**

```shell
case $变量名 in
"值1")
	程序1 #如果变量的值等于值1，则执行程序1
;;
"值2")
	程序2 #如果变量的值等于值1，则执行程序1
#···省略其他分支···
*)
	程序 #如果变量的值都不是以上的值，则执行此程序
;;
esac
```

**案例**

​	当命令行参数是 1 时，输出 周一，是 2 时，就输出 周二，其他情况输出 other

```shell
case $1 in
1)
        echo "周一"
;;
2)
        echo "周二"
;;
*)
        echo "other"
esac
```



#### 17.8.3 for 循环

**基本语法1**

```shell
for 变量 in 值1 值2 值3 ···
do
	程序
done
```

**案例1**

​	打印命令行输出的参数（这里可以看出 `$*`和`$@`的区别）

```shell
# 注意 $* 和 $@ 的区别
for i in "$*"
do
        echo "num is $i"
done
echo "********"
for i in "$@"
do
        echo "num is $i"
done
```

**基本语法2**

```shell
for(( 初始值;循环控制条件;变量变化))
do
	程序
done
```

**案例2**

​	从 1 加到 100 的值输出显示

```shell
# 打印 1 到 100
SUM=0
for(( i=1; i<=100; i++))
do
        SUM=$[$SUM+$i]
done
echo "总和SUM=$SUM"
```





#### 17.8.3 while 循环

**基本语法**

```shell
while [ 条件判断式 ]
do
	程序
done
```

**案例**

​	从命令行输入一个数 n，统计从 1+···+n 的值是多少

```shell
SUM=0
I=0
while [ $I -lt $1 ]
do
        I=$[$I + 1]
        SUM=$[$SUM + $I]
done
echo "SUM=$SUM" 
```



#### 17.8.4 read 读取控制台输入

**基本语法**

```shell
read(选项)(参数)
```

**选项**

- `-p`：指定读取值时的提示符
- `-t`：指定读取值时的等待时间（秒），如果没有在指定时间内输入，就不再等待

**参数**

​	变量：指定读取值的变量名

**应用实例**

- 案例1：读取控制台输入一个 num 值
- 案例2：读取控制台输入一个 num 值，在 10 秒内输入



### 17.9 函数

**函数介绍**

​	Shell 编程和其他编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个

#### 17.9.1 系统函数

**basename 基本语法**

- 功能：返回完整路径最后 / 的部分，常用于获取文件名

- ```shell
  basename [pathname] [suffix]
  ```

- ```shell
  basename [string] [suffix]
  ```

- 功能描述：basename 命令会删除所有的前缀包括最有一个`/`字符，然后将字符串显示出来

**选项**

- suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的suffix 去掉

**应用实例**

​	请返回 `/home/aaa/test.txt` 的 `test.txt` 部分

```shell
basename /home/aaa/test.txt
```



**dirname 基本语法**

- 功能：返回完整路径最后 / 的部分，常用于返回路径部分

- ```shell
  dirname 文件绝对路径
  ```

- 功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录部分），然后返回剩下的路径

**应用案例**

​	请返回 `/home/aaa/test.txt`的`/home/aaa`

```shell
dirname /home/aaa/test.txt
```



#### 17.9.2 自定义函数

**基本语法**

```shell
[ function ] funname[()]
{
	Action;
	[return int;]
}
```

- 调用直接写函数名：`funname [值]`

**应用实例**

​	计算输入两个参数的和（动态获取），getSum

```shell
# 定义函数
function getSum() {
        SUM=$[$n1+$n2]
        echo "SUM=$SUM"
}

# 输入两个值
read -p "请输入一个数n1=" n1
read -p "请输入一个数n2=" n2

# 调用
getSum $n1 $n2
```



### 17.10 Shell 编程综合案例

**需求分析**

1. 每天凌晨 2:30 备份 数据库 crispEduDB 到 `/data/backup/db`
2. 备份开始和备份结束能够给出相应的提示信息
3. 备份后文件要求以时间为文件名，并打包成 `.tar.gz` 的形式，比如：`2022-07-28_103101.tar.gz`
4. 在备份的同时，检查是否有10天前备份的数据库文件，如果有就将其删除

**脚本文件代码**

`mysql_db_backup.sh `

```shell
#!/bin/bash
# 备份目录
BACKUP=/data/backup/db

# 当前时间
DATETIME=$(date +%Y-%m-%d_%H%M%S)
echo $DATETIME

# 数据库的地址
HOST=localhost
# 数据库用户名
DB_USER=root
# 数据库密码
DB_PW=wh1t3zz1002
# 备份的数据库名
DATABASE=crispEdu

# 创建备份目录，如果不存在，就创建
[ ! -d "${BACKUP}/${DATETIME}" ] && mkdir -p "${BACKUP}/${DATETIME}"

# 备份数据库
mysqldump -u${DB_USER} -p${DB_PW} --host=${HOST} -q -R --database ${DATABASE} | gzip > ${BACKUP}/${DATETIME}/${DATETIME.sql.gz}

# 将文件处理成 tar.gz
cd ${BACKUP}
tar -zcvf $DATETIME.tar.gz ${DATETIME}
# 删除对应的备份目录
rm -rf ${BACKUP}/${DATETIME}

# 删除 10 天前的备份目录
find ${BACKUP} -atime +10 -name "*.tar.gz" -exec rm -rf {} \;
echo "备份数据库${DATABASE}"
```

放入 crond 中

```shell
crond -e
```

```shell
30 2 * * * /usr/sbin/mysql_db_backup.sh 
```





## 第十八章 Python开发平台Ubuntu

### 18.1 Ubuntu 的 root 用户

**介绍**

​	安装 Ubuntu 成功后，都是普通用户权限，并没有最高 root 权限，如果需要使用 root 权限的时候，通常都会在命令前面加上 sudo。有时候会很麻烦

​	我们一般使用 su 命令来直接切换到 root 用户的，但是如果没有给 root 设置初始密码，就会抛出一个 `su:Authentication failure`这样的问题。所以，我们只要给 root 用户设置一个初始密码就好了

**给 root 用户设置密码并使用**

1. 输入`sudo passwd`命令，输入一般用户密码并设定 root 用户密码
2. 设定 root 密码成功后，输入`su`命令，并输入刚才设置的 root 密码，就可以切换成 root 了。提示符`$`代表一般用户，提示符`#`代表 root 用户
3. 输入`exit`命令，退出 root 用户并返回一般用户



### 18.2 Ubuntu 下开发 Python

**说明**

​	安装好 Ubuntu 后，默认就已经安装好 Python 的开发环境

**在 Ubuntu 下开发一个 Python 程序**

1. `vim hello.py`
2. `python3 hello.py`



### 18.2 APT 软件管理和远程登陆

**apt 介绍**

​	apt 是 Advanced Packaging Tool 的简称，是一款安装包管理工具。在 Ubuntu 下，我们可以使用 apt 命令进行软件包的安装、删除、清理等，类似于 Windows 中的软件管理工具

**Ubuntu 软件操作相关命令**

```shell
sudo apt-get update#更新源
sudo apt-get install package#安装包
sudo apt-get remove package#删除包

sudo apt-cache search package#搜索软件包
sudo apt-cache show package#获取包的相关信息
sudo apt-get install package --reinstall#重新安装包

sudo apt-get -f install#修复安装
sudo apt-get remove package --purge#删除包，包括配置文件
sudo apt-get build-dep package#安装相关的编译环境

sudo apt-get update#更新已安装的包
sudo apt-get dist-upgrade#升级系统
sudo apt-cache depends package#了解使用该包依赖哪些包
sudo apt-cache rdepends package#查看该包被哪些包依赖
sudo apt-get source package#下载该包的源代码
```



### 18.3 远程登陆 Ubuntu

**ssh 介绍**

​	SSH 是 Secure Shell 的缩写，由 IETF 的网络工作小组所制定；SSH 为建立在应用层和传输层基础上的安全协议

​	SSH 是目前较可靠，专为远程登陆会话和其他网络服务提供安全性的协议。常用于远程登陆。几乎所有 UNIX/Linux 平台都可运行SSH

​	使用 SSH 服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果 A 机器想被 B 继器远程控制，那么 A 机器需要安装 SSH 服务器，B 机器需要安装 SSH 客户端

​	和 CentOS 不一样，Ubuntu 默认没有安装 SSHD 服务（使用 netstat 指令查看：apt install net-tools），因此，我们不能进行远程登陆

**安装 SSH 和启用**

```shell
sudo apt-get install openssh-server
```

执行上面指令后，在当前这台 Linux 上就安装了 SSH 服务端和客户端

```shell
service sshd restart
```

执行上面指令，就启动了 sshd 服务。会监听端口 22

**从一台 Linux 系统远程登陆到另一台 Linux 系统**

在创建服务器集群时，会使用到该技术

基本语法

```shell
ssh 用户名@IP
# 例如
ssh godcrisp@192.168.200.129
```

使用 ssh 访问，如访问出现错误。可查看是否有该文件

`~/.ssh/known_ssh`

尝试删除该文件解决，一般不会有问题

登出：`exit`或者`logout`





## 第十九章 日志管理

### 19.1 基本介绍

1. 日志文件是重要的系统信息文件，其中记录了许多重要的系统文件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息
2. 日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者收到攻击时攻击者留下的痕迹
3. 可以这样理解，日志是用来记录重大事件的工具

**系统常用的日志**

- `/var/log/`目录就是系统日志文件的保存位置

| 日志文件            | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| `/var/log/boot.log` | *系统启动日志                                                |
| `/var/log/cron`     | *记录与系统定时任务相关的日志                                |
| `/var/log/cups/`    | 记录打印信息的日志                                           |
| `/var/log/dmesg`    | 记录了系统在开机时内核自检的信总。也可以使用 dmesg 命令直接查看内核自检信息 |
| `/var/log/btmp`     | 记录错误登陆的日志。这个文件是二进制文件，不能直接用 vi 查看，而要使用 lastb 命令查看 |
| `/var/log/lastlog`  | *记录系统中所有用户最后一次登陆时间的日志。这个文件也是二进制文件。用使用 lastlog 命令查看 |
| `/var/log/mailog`   | *记录邮件信息的日志                                          |
| `/var/log/message`  | *记录系统重要消息的日志，这个日志文件中会记录 Linux 系统的绝大多数重要信息。如果系统出现问题，首先要检查的就是这个文件 |
| `/var/log/secure`   | *记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，比如系统的登陆、ssh 的登陆、su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 |
| `/var/log/wtmp`     | 永久记录所有用户的登陆、注销信息，同时记录系统的启动、重启、关机。是二进制文件。要使用 last 命令查看 |
| `/var/log/ulmp`     | *记录当前已经登陆的用户的信息。这个文件会随着用户的登陆和注销而不断变化，只记录当前登录用户的信息。这个文件不能用 vi 查看，而要使用 w、who、users 等命令查看 |

**应用案例**

​	使用 root 用户登录 xshell ，第一次使用错误的密码，第二次使用正确的密码登陆成功看看在日志文件`/var/log/secure`里有没有记录



### 19.2 日志管理服务 rsyslogd

- CentOS7.6 日志服务是 rsyslogd，CentOS6.x 日志服务是 syslogd。rsyslogd 功能更强大
- rsyslogd 的使用、日志文件的格式，和 syslogd 服务兼容

**查询 Linux 中的 rsyslogd 服务是否启动**

```shell
ps aux | grep "rsyslog" | grep -v "grep"
```

**查询 rsyslogd 服务的自启动状态**

```shell
systemctl list-unit-files | grep rsyslog
```

**配置文件：`/etc/rsyslog.conf`**

编辑文件时的格式为：`*.*`  存放日志文件

其中第一个 * 代表日志类型，第二个 * 代表日志级别

**日志类型**分为：

- `auth`                        ## pam 产生的日志
- `authpriv`                 ## ssh、ftp 等登录信息的验证信息
- `corn`                        ## 时间任务相关
- `kern`                        ## 内核
- `lpr`                          ## 打印
- `mail`                        ## 邮件
- `mark(syslog)-rsyslog`         ## 服务内部的信息，时间标识
- `news`                        ## 新闻组
- `user`                        ## 用户程序产生的相关信息
- `uucp`                        ## unix to unix copy 主机之间相关的通信
- `local 1-7`               ## 自定义的日志设备

**日志级别**分为：

- `debug`              ## 有调试信息的，日志通信最多
- `info`                ## 一般信息日志，最常用
- `notice`             ## 最具有重要性的普通条件的信息
- `warning`           ## 警告级别
- `err`                  ## 错误级别，阻止某个功能或者模块不能正常工作的信息
- `crit`                 ## 严重级别，阻止整个系统或者整个软件不能正常工作的信息
- `alert`               ## 需要立即修改的信息
- `emerg`               ## 内核崩溃等重要信息
- `none`                 ## 什么都不记录

注意：从上到下，级别从低到高，记录东西越来越少

**由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下 4 项：**

1. 事件产生的时间
2. 产生事件的服务器的主机名
3. 产生事件的服务器或程序名
4. 事件的具体信息

**日志查看实例**

​	查看一下`/var/log/secure`日志，这个日志中记录的是用户验证和授权方面的信息 来分析如何查看

**日志管理服务应用实例**

​	在`/etc/rsyslog.conf`中添加一个日志文件`/var/log/crisp.log`，当有事件发送时（比如 sshd 服务相关事件），该文件会接收到信息并保存。演示 重启，登陆 的请阔，看看是否有日志保存



### 19.3 日志轮替

**基本介绍**

​	日志轮替就是把旧的日志移动并改名，同时建立新的空日志文件，当九日至文件超出保存的范围之后，就会进行删除

**日志轮替文件命名**

1. CentOS7 使用 logrotate 进行日志轮替管理，要想改变日志轮替名字，通过`/etc/logrotate.conf`配置文件中`dateext`参数
2. 如果配置文件中有`dateext`参数，那么日志会用日期来作为日志文件的后缀，例如`secure-20220728`。这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可
3. 如果配置文件中没有`dateext`参数，日志文件就需要进行改名。当第一次进行日志轮替时，当前的`secure`日志会自动改名`secure.1`，然后新建`secure`日志，用来保存新的日志。当第二次进行日志轮替时`secure.1`会自动改名为`secure.2`，当前的`secure`日志会自动改名为`secure.1`，然后也会新建`secure`日志，用来保存新的日志，以此类推

**配置文件**

​	`/etc/logrotate.confs`

​	说明：也可以把某个日志文件的轮替规则，写到`/etc/logrotate.d/`里面

**参数说明**

| 参数                    | 参数说明                                                     |
| ----------------------- | ------------------------------------------------------------ |
| daily                   | 日志的轮替周期是每天                                         |
| weekly                  | 日志的轮替周期是每周                                         |
| monthly                 | 日志的轮替周期是每月                                         |
| rotate 数字             | 保留的日志文件个数。0 指没有备份                             |
| compress                | 日志轮替时，旧的日志进行压缩                                 |
| create mode owner group | 建立新日志，同时指定新日志的权限与所有者和所属组             |
| mail address            | 当日志轮替时，输出内容通过邮件发送到指定的邮件地址           |
| missingok               | 如果日志不存在，则忽略该日志的警告信息                       |
| notifempty              | 如果日志为空文件，则不进行日志轮替                           |
| minisize 大小           | 日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间到达也不轮替 |
| size 大小               | 日志只有大于指定大小蔡景行日志轮替，而不是按照时间轮替       |
| dateext                 | 使用日期作为日志论题文件的后缀                               |
| sharedscripts           | 在此关键字之后的脚本只执行一次                               |
| prerotate/endscript     | 在日志轮替之前执行脚本命令                                   |
| postrotate/endscript    | 在日志轮替之后执行脚本命令                                   |

**把自己的日志加入日志轮替**

- 第一种方法是直接在`/etc/logrotate.conf`配置文件中写入该日志的轮替策略
- 第二种是在`/etc/logrotate.d/`目录中新建该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被 include 到主文件中，所以可以把日志加入轮替
- 推荐使用第二种方法，因为系统中需要轮替的日志非常多，如果全写入配置文件中，那么这个文件的可管理性就会非常差，不利于此文件的维护

**应用实例**

```shell
/var/log/crisp.log
{
	missingok
	daily
	copytruncate
	rotate 7
	notifempty
}
```

**日志轮替机制原理**

​	日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在`/etc/cron.daily/`目录，就会发现这个目录中是有 logrotate 文件（可执行），logrotate 通过这个文件依赖定时任务执行的



### 19.4 查看内存日志

- `journalctl`可以查看内存日志

**常用指令**

| 指令                                        | 作用                                     |
| ------------------------------------------- | ---------------------------------------- |
| `journalctl`                                | 查看全部                                 |
| `journalctl -n 3`                           | 查看最新 3 条                            |
| `journalctl --since 19:00 --until 19:10:10` | 查看起始时间到结束时间的日志可加日期     |
| `journalctl -p err`                         | 报错日志                                 |
| `journalctl -o verbose`                     | 日志详细内容                             |
| `journalctl_PID=125 _COMM=sshd`             | 查看包含这些参数的日志（在详细日志查看） |

**演示案例**

​	使用`journalctl | grep sshd`来看看用户登陆清空，重启系统，再次查询，看看有什么变化





## 第二十章 搭建自己的 Linux 系统

### 20.1 基本原理

**启动流程介绍：**

1. 首先 Linux 要通过自检，检查硬件设备又饿米有故障
2. 如果有多块启动盘的话，需要在 BIOS 中选择启动磁盘
3. 启动 MBR 中的 bootloader 引导程序
4. 加载内核文件
5. 执行所有进程的父进程、老祖宗 systemd
6. 欢迎界面

在 Linux 的启动流程中，加载内核文件时关键文件：

- kernel 文件：`vmlinuz-3.10.0-957.el7.x86_64`
- initrd 文件：`initramfs-3.10.0-957.el7.x86_64.img`

**制作min linux思路分析**

1. 在现有的 Linux 系统（CentOS7.6）上加一块硬盘`/dev/sdb`，在银盘上分两个分区，一个是`/boot`，一个是`/`，并将其格式化。需要明确的是，现在加的这个硬盘在现有的 Linux 系统中是`/dev/sdb`，但是，当我们把东西全部设置好时，需要把这个硬盘拔除，放在新的系统上，此时，就是`/dev/sda`
2. 在`/dev/sdb`硬盘上，将其打造成独立的 Linux 系统，里面的所有文件是选哟拷贝进去的
3. 作为能独立运行的 Linux 系统，内核一定不能少，要把内核文件和 initramfs 文件也一起拷到`/dev/sdb`上
4. 以上步骤完成，我们自制 Linux 就完成，创建一个新的 Linux 虚拟机，将其硬盘指向我们床啊金的硬盘，启动即可





## 第二十一章 Linux 内核源码&内核升级

### 21.1 Linux0.01 内核源码

**基本介绍**

​	Linux 的内核源码可以从网上下载，解压缩后文件也都位于 Linux 目录下。内核源代码有很多版本，可以从 Linux0.01 内核入手，总共代码 1w 行左右，最新版本 5.9.8 总共代码超过 700w 行，非常庞大

内核地址：https://www.kernel.org/

**阅读内核源码技巧**

1. Linux0.01 的阅读需要懂 C 语言
2. 、阅读代码前，应知道 Linux 内核源码的整体分布情况。现代的操作系统一般由进程管理、内存管理、文件系统、驱动程序和网络等组成。Linux 内核源码的各个目录大致与此对应
3. 在阅读或顺序上，有横向与纵向之分。所谓纵向就是顺着程序的执行顺序逐步进行；所谓横向，就是按模块进行。它们经常结合在一起进行
4. 对于 Linux 启动的代码可顺着 Linux 的启动顺序一步步来阅读；对于像内存管理部分，可以单独拿出来进行阅读分析。实际上这是一个反复的过程，不可能读一遍就懂



### 21.2 Linux 内核最新版和内核升级

主要代码：

```shell
uname -a	# 查看当前的内核版本
yum info kernel -q	# 检测内核版本，显示可以升级的内核
yum update kernel	# 升级内核
yum list kernel -q	# 查看已经安装的内核
```





## 第二十二章 Linux 系统备份与恢复

**基本介绍**

​	实体机无法做快照，如果系统出现异常或者数据损坏，后果严重，要重做系统，花卉造成数据丢失。所以我们可以使用备份和恢复技术

Linux的备份和恢复有两种方式：

1. 把需要的文件（或者分区）用 TAR 打包就行，下次需要恢复的时候，再解压开覆盖即可
2. 使用 dump 和 restore 命令

**安装 dump 和 restore**

```shell
yum -y install dump
yum -y install restore
```



### 22.1 使用 dump 完成备份

**基本介绍**

​	dump 支持分卷和增量备份（所谓增量备份是指备份上次备份后，修改/增加过的文件，也称差异备份）

**dump 语法说明**

```shell
dump [-cu] [-123456789] [-f<备份后文件名>] [-T<日期>] [目录或文件系统]
dump []-wW
```

- `-c`：创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头
- `-123456789`：备份的层级。0 为最完整备份，会备份所有文件。若指定 0 以上层级，则备份至上一次备份以来修改或新增的文件，到 9 后，可以再次轮替
- `-f<备份后文件名>`：只当备份后文件名
- `-j`：调用 bzlib 库压缩备份文件，也就是将备份后的文件压缩成 bz2 格式，让文件更小
- `-T<日期>`：指定开始备份的时间与日期
- `-u`：备份完毕后，在`/etc/dumpdates`中记录备份的文件系统，层级，日期与时间等
- `-t`：指定文件名，若该文件已存在备份文件中，则列出名称
- `-W`：显示需要备份的文件及其最后一次备份的层级，时间，日期
- `-w`：与 -W 类似，但仅显示需要备份的文件

**应用案例1**

​	将`/boot`目录所有内容备份到`/opt/boot.bak0.bz2`文件中，备份层级为 0

```shell
dump -0uj -f /opt/boot.bak0.bz2 /boot
```

**应用案例2**

​	在`/boot`目录下增加新文件夹，备份层级为 1（之备份上次使用层次 0 备份后发生改变的数据），注意比较看啊可能这次生成的备份文件由多大

```shell
dump -1uj -f /opt/boot.bak1.bz2 /boot
```

注意：通过 dump 指令再配合 crontab 可以实现无人值守备份

**dump 备份文件或者目录**

​	前面我们在备份分区时，是可以支持增量备份的，如果*备份文件或者目录，不再支持增量备份*，即只能使用 0 级别备份



### 22.2 使用 restore 完成恢复

**基本介绍**

​	restore 命令用来恢复已备份的文件，可以从 dump 生成的备份文件中恢复原文件

**基本语法**

```shell
restore [模式选项] [选项]
```

说明下面四个模式，不能混用，在一次命令中，只能指定一种

- `-C`：使用对比模式，将备份的文件与已存在的文件相互对比
- `-i`：使用交互模式，在进行还原操作时，restore 指令将依序询问用户
- `-r`：进行还原模式
- `-t`：查看模式，看备份文件有哪些文件

选项

- `-f<备份设备>`：从指定文件中读取备份数据，进行还原操作

**应用案例1**

​	restore 命令比较模式，比较备份文件和源文件的区别

```shell
mv /boot/hello.java /booot/hello100.java
restore -C -f boot.bak1.bz2	# 注意和最新文件比较
```

**应用案例2**

​	restore 命令查看模式，看备份文件优先哪些数据/文件

```shell
restore -t -f boot.bak0.bz2
```

**应用案例3**

​	restore 命令还原模式，注意细节：如果你有增量备份，需要把增量备份文件也进行恢复，有几个增量备份文件，就要恢复几个，按循序来恢复即可

 ```shell
 mkdir /opt/boottmp
 cd /opt/boottmp
 restore -r -f /opt/boot.bak0.bz2 # 恢复至第一次完全备份状态
 restore -r -f /opt/boot.bak1.bz2 # 恢复至第二次增量备份状态
 ```

**应用案例4**

​	restore 命令恢复备份的文件，或者整个目录的文件

```shell
mkdir /opt/etctmp
cd /opt/etctmp
restore -r -f /opt/etc.bak0.bz2
```





## 第二十三章 Linux 可视化管理

### 23.1 webmin

**基本介绍**

​	Webmin 是功能强大的基于 Web 的 Unix/Linux 系统管理工具。管理员通过浏览器访问 Webmin 的各种管理功能并完成相应的管理操作。除了各版本的 Linux 外还可以用：AIX、HPUX、Solaris、Unixware、Irix 和 reeBSD 等系统

**安装 Webmin&配置**

1. 下载地址：http://download.webmin.com/download/yum/，用下载工具下载即可

   也可以使用`wget http://download.webmin.com/download/yum/webmin-1.700-1.noarch.rpm`

2. 安装：`rpm -ivh webmin-1.700-1.noarch.rpm`

3. 重置密码：`/usr/libexec/webmin/changepass.pl /etc/webmin root test`

   root 就是 webmin 的用户名，不是 OS 的，这里就是把 webmin 的 root 用户密码改成 test

4. 修改 webmin 服务的端口号（默认是 10000 处于安全目的）

   `vim /etc/webmin/miniserv.conf`修改端口

   将 `port=10000`改为其他端口号，如`port=6666`

5. 重启 webmin

   ```shell
   /etc/webmin/restart	# 重启
   /etc/webmin/start	# 启动
   /etc/webmin/stop	# 停止
   ```

6. 防火墙开放 6666 端口

   ```shell
   firewall-cmd --zone=public --add-port=6666/tcp --permanent	# 配置防火墙开放端口
   firewall-cmd --reload	# 更新防火墙配置
   firewall-cmd --zone=public --list-ports	# 查看已经开放的端口号
   ```

7. 登陆 webmin

   http://ip:6666可以访问

   用 root 账号和重置的新密码 test



### 23.2 bt（宝塔）

**基本介绍**

​	bt 宝塔 Linux 面板是提升运维效率的服务器管理软件，支持一键 LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA 等多项服务器管理功能

**安装和使用**

1. 安装`yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh`
2. 安装成功后控制台会显示登陆地址，账户密码，复制浏览器打开登陆

- 如果 bt 的用户名，密码忘记了，使用 `bt default`可以查看





## 第二十四章 Linux 面试题

**分析日志 t.log（访问量），将各个 ip 地址截取，并统计出现次数，并按从大到小排序（腾讯）**

```shell
http://192.168.200.10/index1.html
http://192.168.200.10/index2.html
http://192.168.200.20/index1.html
http://192.168.200.30/index1.html
http://192.168.200.40/index1.html
http://192.168.200.30/order.html
http://192.168.200.10/order.html
```

指令：

```shell
cat t.txt | cut -d '/' -f 3 | sort | uniq -c | sort -nr
```



**统计连接到服务器的各个 ip 情况，并按连接数从大到小排序（腾讯）**

指令：

```shell
netstat -an | grep ESTABLISHED | awk -F " " '{print $5}' | awk -F ":" '{print $1}' | sort | uniq -c | sort -nr
```

